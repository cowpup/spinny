<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Spinning Pok√©mon Card</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      canvas {
        display: block;
      }
      #upload-container {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 10;
        background: rgba(255, 255, 255, 0.9);
        padding: 10px;
        border-radius: 8px;
      }
      .slider-container {
        display: flex;
        align-items: center;
        gap: 5px;
        margin: 5px 0;
      }
      .slider-container input[type=number] {
        width: 50px;
      }
    </style>
    <script src="https://unpkg.com/three@0.148.0/build/three.min.js"></script>
  </head>
  <body>
    <div id="upload-container">
      <label>Front Image: <input type="file" id="frontInput" accept="image/*"></label><br>
      <label>Back Image: <input type="file" id="backInput" accept="image/*"></label><br>
      <label>Background Image: <input type="file" id="bgInput" accept="image/*"></label><br>
      <button id="submitBtn">Submit</button><br>

      <div class="slider-container">
        <label for="adjustX">Adjust Horizontal (X):</label>
        <input type="range" id="adjustX" min="-5" max="5" step="0.1" value="0">
        <input type="number" id="adjustXVal" value="0">
      </div>
      <div class="slider-container">
        <label for="adjustY">Adjust Vertical (Y):</label>
        <input type="range" id="adjustY" min="-5" max="5" step="0.1" value="0.3">
        <input type="number" id="adjustYVal" value="0.3">
      </div>
      <div class="slider-container">
        <label for="adjustPitch">Adjust Pitch (Z):</label>
        <input type="range" id="adjustPitch" min="-1.5" max="1.5" step="0.05" value="0">
        <input type="number" id="adjustPitchVal" value="0">
      </div>
      <div class="slider-container">
        <label for="rotationSpeed">Rotate Speed:</label>
        <input type="range" id="rotationSpeed" min="-0.1" max="0.1" step="0.001" value="0.0085">
        <input type="number" id="rotationSpeedVal" value="0.0085">
      </div>
      <div class="slider-container">
        <label for="scale">Scale:</label>
        <input type="range" id="scale" min="0.1" max="2" step="0.01" value="0.9">
        <input type="number" id="scaleVal" value="0.9">
      </div>
    </div>
    <button id="exportBtn" style="display:none; position:absolute; top:10px; right:10px; z-index:10;">Export GIF</button>
    <script>
      let frontTexture, backTexture, cardMesh, backgroundPlane;
      let rotationSpeed = 0.0085;
      let scaleValue = 0.9;
      let cardX = 0, cardY = 0.3, pitch = 0;

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x000000, 0);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      camera.position.set(0, 2, 8);
      camera.lookAt(0, 0, 0);

      scene.add(new THREE.AmbientLight(0x404040, 1.5));

      const spotlight = new THREE.SpotLight(0xffffff, 1);
      spotlight.position.set(0, 10, 5);
      spotlight.castShadow = true;
      spotlight.angle = Math.PI / 6;
      spotlight.penumbra = 0.3;
      spotlight.shadow.mapSize.width = 1024;
      spotlight.shadow.mapSize.height = 1024;
      scene.add(spotlight);

      function createCard() {
        if (cardMesh) scene.remove(cardMesh);

        const geometry = new THREE.BoxGeometry(3.5, 5, 0.2);
        const materials = [];
        const defaultEdge = new THREE.MeshStandardMaterial({ color: 0x888888 });
        const blank = new THREE.MeshStandardMaterial({ color: 0x222222 });

        for (let i = 0; i < 6; i++) {
          if (i === 4) {
            materials.push(frontTexture ? new THREE.MeshStandardMaterial({ map: frontTexture }) : blank);
          } else if (i === 5) {
            materials.push(backTexture ? new THREE.MeshStandardMaterial({ map: backTexture }) : blank);
          } else {
            materials.push(defaultEdge);
          }
        }

        cardMesh = new THREE.Mesh(geometry, materials);
        cardMesh.scale.set(scaleValue, scaleValue, scaleValue);
        cardMesh.castShadow = true;
        cardMesh.receiveShadow = false;
        cardMesh.position.set(cardX, cardY, 0);
        cardMesh.rotation.x = pitch;
        scene.add(cardMesh);
      }

      function handleFile(input, callback) {
        const file = input.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function (event) {
          const img = new Image();
          img.onload = function () {
            const texture = new THREE.Texture(img);
            texture.needsUpdate = true;
            texture.colorSpace = THREE.SRGBColorSpace;
            callback(texture);
          };
          img.src = event.target.result;
        };
        reader.readAsDataURL(file);
      }

      function setBackground(imageUrl) {
  const loader = new THREE.TextureLoader();
  loader.load(imageUrl, texture => {
    texture.colorSpace = THREE.SRGBColorSpace;

    const bgGeometry = new THREE.PlaneGeometry(20, 20);
    const bgMaterial = new THREE.MeshBasicMaterial({ map: texture });
    if (backgroundPlane) scene.remove(backgroundPlane);
    backgroundPlane = new THREE.Mesh(bgGeometry, bgMaterial);
    backgroundPlane.position.set(0, 0, -5);
    scene.add(backgroundPlane);
  });
}
        });
      });
      document.getElementById('backInput').addEventListener('change', e => {
        handleFile(e.target, texture => {
          backTexture = texture;
          createCard();
        });
      });
      document.getElementById('bgInput').addEventListener('change', e => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function (event) {
          setBackground(event.target.result);
        };
        reader.readAsDataURL(file);
      });
      document.getElementById('submitBtn').addEventListener('click', () => {
        document.getElementById('upload-container').style.display = 'none';
        document.getElementById('exportBtn').style.display = 'block';
      });

      function bindSlider(id, numId, callback) {
        const slider = document.getElementById(id);
        const number = document.getElementById(numId);
        slider.addEventListener('input', () => {
          number.value = slider.value;
          callback(parseFloat(slider.value));
        });
        number.addEventListener('input', () => {
          slider.value = number.value;
          callback(parseFloat(number.value));
        });
      }

      bindSlider('adjustX', 'adjustXVal', v => { cardX = v; if (cardMesh) cardMesh.position.x = v; });
      bindSlider('adjustY', 'adjustYVal', v => { cardY = v; if (cardMesh) cardMesh.position.y = v; });
      bindSlider('adjustPitch', 'adjustPitchVal', v => { pitch = v; if (cardMesh) cardMesh.rotation.x = v; });
      bindSlider('rotationSpeed', 'rotationSpeedVal', v => { rotationSpeed = v; });
      bindSlider('scale', 'scaleVal', v => { scaleValue = v; if (cardMesh) cardMesh.scale.set(v, v, v); });

      function animate() {
        requestAnimationFrame(animate);
        if (cardMesh) cardMesh.rotation.y += rotationSpeed;
        renderer.render(scene, camera);
      }
      animate();

      setBackground('dripbackground.png');
      const loader = new THREE.TextureLoader();
      loader.load('front.jpg', texture => {
        texture.colorSpace = THREE.SRGBColorSpace;
        frontTexture = texture;
        createCard();
      });
      loader.load('back.jpg', texture => {
        texture.colorSpace = THREE.SRGBColorSpace;
        backTexture = texture;
        createCard();
      });

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      document.getElementById('exportBtn').addEventListener('click', () => {
        const canvas = renderer.domElement;
        const stream = canvas.captureStream(30);
        const recorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
        const chunks = [];

        recorder.ondataavailable = e => chunks.push(e.data);
        recorder.onstop = () => {
          const blob = new Blob(chunks, { type: 'video/webm' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'spinning_card.webm';
          a.click();
        };

        recorder.start();

        const totalFrames = Math.round((Math.PI * 2) / rotationSpeed);
        let framesCaptured = 0;

        const captureInterval = setInterval(() => {
          if (!cardMesh) return;
          cardMesh.rotation.y += rotationSpeed;
          renderer.render(scene, camera);
          framesCaptured++;
          if (framesCaptured >= totalFrames) {
            clearInterval(captureInterval);
            recorder.stop();
          }
        }, 1000 / 30);
      });
    </script>
  </body>
</html>
